#!/usr/bin/env bash

set -euo pipefail

####################
# Set the defaults #
####################

# Set the directory for storing cache files.
#
# This directory contains an image of individual packages.
cache_dir="$PWD/.elinter-cache"

# Set the configuration for storing configuration files.
#
# Configuration files are mostly about Nix, e.g. the lock file
if [[ -v ELINTER_CONFIG_ROOT ]]; then
  config_dir="${ELINTER_CONFIG_ROOT}"
else
  # Fall back to XDG
  # TODO: Set a user configuration directory for Darwin
  config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/elinter"
fi

# The current set of Nix packages
user_nix_sources="${config_dir}/nix/sources.nix"

# Where package source files (actually symlinks) are stored
package_source_root="${cache_dir}/pkg"
# package_output_root="${cache_dir}/pkg-out"

# Directory containing recipes
recipes_dir=${ELINTER_RECIPES_DIR:-.recipes}

###################################
# Read the command line arguments #
###################################

# Initialize variables used inside this script
op=default_check
recipes=()
packages=()
nix_packages=()
unset cleanup
unset remote
unset test_engine
# Cask setting is empty by default, but it is still interpreted as 1
unset use_cask
unset cask_file
unset niv_update
unset git_hook
unset packages_installed
# Configure the linters from the environment variable
if [[ -v ELINTER_LINTERS ]]; then
  mapfile -d' ' -t linters <<<"${ELINTER_LINTERS}"
  # shellcheck disable=SC2206
  linters=(${linters[*]})
else
  # This variable value should be replaced with a literal string to
  # the default linter set using substituteInPlace function of Nix.
  #
  # shellcheck disable=SC2206
  linters=(${lintersAsString})
fi

usage() {
  # Follow the style in docopt https://docopt.org/
  cat <<HELP
Usage: elinter [options] <recipe>...

Options:
  -l             Do only linting (skip byte-compile)
  -b             Do only byte-compile (skip linting)
  -t|--test      Run only tests
  -c             Clean up cache before operation
  -s             Enter a shell with the packages
  --experimental Turn on experimental checks (using melpazoid)
  -B|--buttercup Run buttercup tests
  -E|--ert-runner Run ert-runner tests
  --ert          Run ert tests defined in files
  -e|--emacs VERSION
                 Set the Emacs version
  -r             Fetch the source code from a remote server
  --cask         Detect Cask file and use packages defined in it (default)
  --no-cask      Don't use cask file
  --from-nixpkgs Nix packages added to buildInputs for tests (comma-separated)
  -u|--update    Update Nix dependencies (e.g. emacs-overlay)
  -g             Install pre-commit Git hook
  -V, --version  Show version
HELP
}

version() {
  echo "elinter version ${ELINTER_VERSION:?Unknown version}"
}

# TODO: Use enhanced getopt to parse command line arguments
# See https://gist.github.com/hoylen/6607180 for example

# Loop arguments until it becomes empty
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit
      ;;
    -V|--version)
      version
      exit
      ;;
    -r)
      remote=1
      ;;
    -c|--clean)
      cleanup=1
      ;;
    -e|--emacs)
      EMACS_VERSION="$2"
      shift
      ;;
    -b|--compile)
      op=compile
      ;;
    -l|--lint)
      op=lint
      ;;
    -t|--test)
      op="test"
      ;;
    -s|--shell)
      op=shell
      ;;
    -B|--buttercup)
      test_engine=buttercup
      ;;
    -E|--ert-runner)
      test_engine=ert-runner
      ;;
    --ert)
      test_engine=ert
      ;;
    --experimental)
      linters+=(melpazoid)
      ;;
    --cask)
      use_cask=1
      ;;
    --no-cask)
      use_cask=0
      ;;
    --from-nixpkgs)
      # shellcheck disable=SC2086,SC2206
      nix_packages=(${2/,/ })
      shift
      ;;
    -u|--update)
      niv_update=(emacs-overlay nix-emacs-ci melpazoid)
      ;;
    -g)
      git_hook=1
      ;;
    --)
      # Keep the rest of the arguments as positional arguments
      shift
      break
      ;;
    *)
      if [[ -f "$1" ]]; then
        recipes+=("$1")
      elif [[ -d "${package_source_root}/$1" ]]; then
        packages+=("$1")
      else
        echo "Unsupported arg or missing file: $1" >&2
        exit 1
      fi
      ;;
  esac
  shift
done

#############
# Functions #
#############

# Print a list of Emacs versions based on EMACS_VERSION environment
# variable.
# 
# You can set the version(s) from outside of this script.
emacs_versions() {
  # Use dot to indicate the default value
  local version="${EMACS_VERSION:-.}"
  case "$version" in
    min|latest|all)
      # Run Nix to retrieve a version list from nix-emacs-ci
      nix-instantiate --eval --strict \
                      --arg elispFile "./${PACKAGE_MAIN_FILE}" \
                      --argstr spec "$version" \
                      "share/nix/dynamicVersions.nix" \
        | tr '"[]' '   '
      ;;
    *)
      echo "$version"
      ;;
  esac
}

# Set `emacs` variable to a derivation name in Nix.
#
# Given a version name like 25.1, snapshot, or '.' set in
# `emacs_version` variable, it sets a proper Nix Emacs package name
# like emacs-25-1 provided by nix-emacs-ci.
#
# This function should be called after `emacs_versions` function for
# each package.
set_emacs() {
  case "${emacs_version}" in
    ''|.)
      emacs=emacs
      return
      ;;
    snapshot)
      emacs="emacs-snapshot"
      ;;
    *)
      if [[ "${emacs_version}" =~ ^([[:digit:]]+)\.([[:digit:]])$ ]]; then
        # Skip linting if the Emacs major version is 24.3 or before
        local major=${BASH_REMATCH[1]}
        local minor=${BASH_REMATCH[2]}
        if [[ $major -lt 24 || ( $major -eq 24 && $minor -le 3 ) ]]; then
          echo "WARN: Sorry, elinter supports only Emacs 24.4 and later. Skipping" >&2
          return 1
        fi
        emacs="emacs-${emacs_version/./-}"
      else
        echo "Unsupported Emacs version: ${emacs_version}" >&2
        exit 1
      fi
      ;;
  esac
  ansi --yellow "Using $emacs"
  # Reset the installation state when the Emacs version changes
  packages_installed=0
}

# Update the user Nix sources.json
#
# Names of the sources should be given as arguments.
update_niv_sources() {
  local targets=("$@")

  # If sources.nix does not exist in the user directory,
  # first copy the bundled version.
  if ! [[ -f "${user_nix_sources}" ]]; then
    echo "Installing sources to ${config_dir}..."
    mkdir -p "${config_dir}/nix"
    cp -n -t "${config_dir}/nix" \
       "share/nix/sources.json" "share/nix/sources.nix"
    chmod ug+w "${config_dir}/nix/sources.nix" "${config_dir}/nix/sources.json"
  fi

  if ! command -v niv >/dev/null; then
    echo "Niv is not installed in PATH." >&2
    exit 1
  fi

  echo "Updating Nix dependencies: ${targets[*]}..."

  local initial_dir="$PWD"
  cd "${config_dir}"
  for dep in "${targets[@]}"; do
    niv update "$dep"
  done
  cd "${initial_dir}"
}

# Install pre-commit Git hook
install_git_hook() {
  if ! [[ -d .git ]]; then
    ansi --red --bold \
         "When you add this flag, please run elinter at a Git repository root." >&2
    return 1
  fi

  if [[ -f ".git/hooks/pre-commit" ]]; then
    ansi --red "pre-commit hook is already installed in the repository." >&2
    return 0
  fi

  nix-shell -p pre-commit --run "pre-commit install"

  if [[ -f ".pre-commit-config.yaml" ]]; then
    ansi --red "There is already .pre-commit-config.yaml in the repository. " >&2
    ansi --red "If you want to replace it, you have to remove the existing one." >&2
  else
    cp "share/.pre-commit-config.yaml" .
    chmod u+w .pre-commit-config.yaml
  fi
}

# Discover recipes from `recipes_dir` and set file names in recipes
# variable.
discover_recipes() {
  echo "Looking for recipes in ${recipes_dir}..."
  shopt -s nullglob
  mapfile -t recipes <<<"${recipes_dir}/*"
  # Fill the gap
  # If the file name contain spaces, it may fail
  # shellcheck disable=SC2206
  recipes=(${recipes[*]})

  if [[ ${#recipes[*]} -eq 0 ]]; then
    echo "No recipe file was found." >&2
    echo "You have to specify at least one recipe file or put it in ${recipes_dir}." >&2
    exit 1
  else
    echo "Found ${recipes[*]}"
  fi
}

cleanup_cache() {
  echo "Cleaning up the cache directory..."
  rm -rf "${cache_dir}"
}

# Copy package source files to the cache directory.
#
# Recipe files should be given in `recipes` variable.
# 
# Unless the packages are from remote sources, you should also start
# from the repository root.
#
# This actually creates symlinks to minimize updates on source
# modification.
#
# If files are added/removed, you have to clean the cache.
copy_package_sources() {
  local recipe_file
  echo "Linking package source files..."
  # Ensure the root of the package cache
  mkdir -p "${package_source_root}"
  initialdir="$(pwd)"
  # Operate on each package recipe
  for f in ${recipes[*]}; do
    # Use the base name of the recipe file as the package name
    package=$(basename "$f")
    # Convert to an absolute path
    if [[ "$f" = /* ]]; then
      recipe_file="$(readlink -f "$f")"
    else
      recipe_file="$(readlink -f "$initialdir/$f")"
    fi
    # Add to a list of package names
    packages+=("$package")
    src="$initialdir"
    cd "${package_source_root}"
    if [[ -v remote && $remote = 1 ]]; then
      # When using remote source
      #
      # Clean up the source every time
      rm -rf "$package"
      src=$(nix-instantiate --eval --strict \
              "share/nix/fetchSource.nix" \
              --argstr recipeFile "${recipe_file}" | tr -d \")
    elif [[ -d "$package" ]]; then
      # If there is an existing cache for the package, print the
      # information and skip linking.
      # 
      # You can ensure linking by explicitly purging all existing
      # package cache.
      #
      # TODO: Check for updates in the working tree
      echo
      echo "Reusing the previous settings for $package:"
      ls "$package"
      continue
    fi
    # Generate a script for linking source files using Nix
    instruction=$(nix-build "share/nix/copySource.nix" \
            --no-out-link --quiet --no-build-output \
            --argstr recipeFile "${recipe_file}" --argstr src "$src")
    mkdir "$package"
    cd "${package_source_root}/$package"
    # Run the script to link source files
    # shellcheck disable=SC1090
    . "$instruction"
    # Print the information
    echo
    echo "Package: $package"
    # shellcheck disable=SC2001
    sed 's/^/> /' "${recipe_file}"
    echo -n "Files: "
    ls
  done
  # Restore the working directory
  cd "$initialdir"
}

# Run operation on each package.
#
# The operation is given as the arguments to this function.

# Target packages should be given in `packages` variable, and the
# packages should be already cached. The cache should contain an
# environment file '.elinter-env' for individual packages.
#
# This function is intended for running static linting.
# For testing, use `shell_with_packages`.
# 
# It supports a hook system to alter the behavior.
for_each_package_sources() {
  # Errors are allowed inside this function, but the return code will
  # be set to 1.
  set +e
  local r=0
  # Track a list of failed packages
  local failed_packages=()
  if [[ ${#packages[*]} -gt 1 ]]; then
    multi_packages=1
  else
    multi_packages=0
  fi
  for package in ${packages[*]}; do
    # Fork a subshell to isolate the environment, e.g. variables
    if ! (
      r=0
      cd "${package_source_root}/$package"
      # shellcheck disable=SC1091
      source .elinter-env

      if [[ -v ELINTER_BEFORE_PACKAGE_HOOK && -n "${ELINTER_BEFORE_PACKAGE_HOOK}" ]]; then
        ${ELINTER_BEFORE_PACKAGE_HOOK}
      fi

      ansi --blue --bold "On package ${PACKAGE_NAME}:"
      for emacs_version in $(emacs_versions); do
        if ! set_emacs; then
          break
        fi
        # shellcheck disable=SC2048
        if ! $*; then
          r=1
          # Skip the following versions if any error occurs
          break
        fi
      done

      if [[ $r -eq 0 ]]; then
        if [[ -v ELINTER_PACKAGE_SUCCESS_HOOK && -n "${ELINTER_PACKAGE_SUCCESS_HOOK}" ]]; then
          ${ELINTER_PACKAGE_SUCCESS_HOOK}
        fi
      else
        ansi --red "Package $package failed on some checks."
        if [[ -v ELINTER_PACKAGE_FAILURE_HOOK && -n "${ELINTER_PACKAGE_FAILURE_HOOK}" ]]; then
          ${ELINTER_PACKAGE_FAILURE_HOOK}
        fi
      fi

      if [[ -v ELINTER_AFTER_PACKAGE_HOOK && -n "${ELINTER_AFTER_PACKAGE_HOOK}" ]]; then
        # shellcheck disable=SC2090
        ${ELINTER_AFTER_PACKAGE_HOOK}
      fi

      exit $r
      ); then
      r=1
      failed_packages+=("$package")
    fi
    # Insert an empty line between packages
    gh_workflow_p && echo
  done
  if [[ $r -eq 0 ]]; then
    ansi --green "All checks were successful."
  else
    ansi --red "Some checks failed."
    if [[ ${multi_packages} -gt 0 ]]; then
      echo "Failed packages: ${failed_packages[*]}"
    fi
  fi
  return $r
}

# Run a command in a linting environment for a specific package.
#
# This should be called inside `for_each_package_sources`.
emacs_dev_shell() {
  "${nix_shell_bin}" "share/nix/emacs.nix" -A shellForCI \
          --arg sources "${user_nix_sources}" \
          --argstr emacs "$emacs" \
          --argstr mainFile "$(pwd)/${PACKAGE_MAIN_FILE}" \
          --argstr linters "${linters[*]}" \
          --argstr localPackageNames "${packages[*]}" \
          --argstr localPackageRoot "${package_source_root}" \
          "$@"
}

# Install Emacs package dependencies for a specific package.
#
# This should be called inside `for_each_package_sources`.
install_package_deps() {
  if ! [[ -v packages_installed && "${packages_installed}" = 1 ]]; then
    workflow_start_group "Install dependencies for the package"
    emacs_dev_shell --run exit
    workflow_end_group
    packages_installed=1
  fi
}

# Run static linting on a specific package.
#
# This should be called inside `for_each_package_sources`.
lint_package() {
  install_package_deps
  workflow_with_group "Lint" emacs_dev_shell --run elinter-run-linters
}

# Byte-compile a package.
#
# This should be called inside `for_each_package_sources`.
compile_package() {
  install_package_deps
  emacs_dev_shell --run elinter-byte-compile
}

# Run static linting and byte-compile a package.
#
# This should be called inside `for_each_package_sources`.
lint_and_compile_package() {
  local r=0
  lint_package || r=1
  compile_package || r=1
  return $r
}

# Run a command in an environment where all package sources are
# available.
shell_with_packages() {
  local loadpath=()
  local mainfiles=()
  initialdir="$PWD"
  for package in ${packages[*]}; do
    unset PACKAGE_NAME
    unset PACKAGE_FILES
    unset PACKAGE_ELISP_FILES
    unset PACKAGE_MAIN_FILE
    cd "${package_source_root}/$package"
    # shellcheck disable=SC1091
    source .elinter-env
    loadpath+=("$PWD")
    mainfiles+=("$(readlink -e "${PACKAGE_MAIN_FILE}")")
  done
  cd "$initialdir"
  local r=0
  for emacs_version in $(emacs_versions); do
    if ! set_emacs; then
      break
    fi
    # shellcheck disable=SC2048
    if ! "${nix_shell_bin}" "share/nix/emacsTest.nix" \
          --argstr emacs "$emacs" \
          --argstr loadPath "${loadpath[*]@Q}" \
          --argstr mainFiles "${mainfiles[*]@Q}" \
          "$@"; then
      r=1
      # Skip the following versions if any error occurs
      break
    fi
  done
  return $r
}

# Run tests based on `test_engine` variable.
run_tests() {
  ansi --blue --bold "Tests"
  local nix_args=()
  if [[ -v cask_file ]]; then
    nix_args+=("--argstr" "caskFile" "${cask_file}")
  fi
  if [[ -v nix_packages && ${#nix_packages[*]} -gt 0 ]]; then
    nix_args+=("--argstr" "extraBuildInputsFromNixPkgs" "${nix_packages[*]}")
  fi
  case "${test_engine}" in
    buttercup)
      # shellcheck disable=SC2086
      shell_with_packages \
        ${nix_args[*]} \
        --arg extraPackReqs '["buttercup"]' \
        --arg extraBuildInputs "import share/nix/buttercup.nix" \
        --run "buttercup $*"
      ;;
    ert-runner)
      # shellcheck disable=SC2086
      shell_with_packages \
        ${nix_args[*]} \
        --arg extraPackReqs '["ert-runner"]' \
        --run "emacs -Q --batch -l ert-runner"
      ;;
    ert)
      # Extra arguments passed to elinter command are loaded in the
      # Emacs session.
      local emacs_args=()
      for arg; do
        emacs_args+=("-l" "$arg")
      done
      # ert is a built-in package, so extraPackReqs is unnecessary
      # shellcheck disable=SC2086
      shell_with_packages \
        ${nix_args[*]} \
        --run "emacs -Q --batch -l ert ${emacs_args[*]} -f ert-run-tests-batch-and-exit"
      ;;
  esac
}

setup_github_workflow_annotations() {
  mkdir -p "${cache_dir}"
  # Lint and byte-compile errors are saved to this file
  export ELINTER_LOG_FILE="$PWD/elinter.log"

  ELINTER_BEFORE_PACKAGE_HOOK="touch ${ELINTER_LOG_FILE}"
  ELINTER_AFTER_PACKAGE_HOOK="rm -f ${ELINTER_LOG_FILE}"
  # Produce errors on a package
  ELINTER_PACKAGE_FAILURE_HOOK="elinter-github-logger"
}

####################
# Main entry point #
####################

# The order matters here, so don't reorder them carelessly.

# Load functions related GitHub Actions from share/workflow.bash in
# this repository.
# The path should be replaced with an absolute path using
# substituteInPlace function of Nix.
# 
# shellcheck disable=SC1091
. 'share/workflow.bash'

workflow_start_group "Initialization"

if [[ -v GITHUB_ACTIONS ]]; then
  # Force setting TERM to enable color output
  export TERM=ansi
fi

# Source "ansi" script to load "ansi" function.
# 'ansi/ansi' should be replaced with an absolute path using
# substituteInPlace function of Nix.
# 
# shellcheck disable=SC1091
. 'share/ansi'

if nix_shell_bin="$(command -v cached-nix-shell)"; then
  echo "Using cached-nix-shell"
  echo
else
  nix_shell_bin=nix-shell
fi

if [[ -v cleanup && $cleanup = 1 ]]; then
  cleanup_cache
  echo
fi

if [[ -v niv_update ]]; then
  update_niv_sources "${niv_update[@]}"
fi
if [[ -f "${user_nix_sources}" ]]; then
  echo "Using Nix sources maintained by the user"
fi

# This should be run after the possible update of dependencies.
if [[ -v git_hook && "${git_hook}" = 1 ]]; then
  install_git_hook
fi

# For most operations, at least one recipe is mandatory
if [[ ${#recipes[*]} -eq 0 && ${#packages[*]} -eq 0 ]]; then
  discover_recipes
  echo
fi

# Link package sources defined within the recipes
if [[ ${#recipes[*]} -gt 0 ]]; then
  copy_package_sources
fi

export ELINTER_LINTERS="${linters[*]}"

if ! [[ -v use_cask && "${use_cask}" = 0 ]]; then
  if [[ -f Cask ]]; then
    cask_file="$(readlink -f Cask)"
  elif [[ -v use_cask && "${use_cask}" = 1 ]]; then
    echo "WARNING: Cask option is set, but no Cask file is found."
  fi
fi

# Enable features that are specific to GitHub Actions
if [[ -v GITHUB_ACTIONS && "${GITHUB_ACTIONS}" = true ]]; then
  # Allow preventing annotations by setting ELINTER_NO_ANNOTATE_GITHUB
  # e.g. for testing error cases
  if [[ ! -v ELINTER_NO_ANNOTATE_GITHUB ]]; then
    setup_github_workflow_annotations
  fi
fi

workflow_end_group

case "$op" in
  default_check)
    r=0
    for_each_package_sources lint_and_compile_package || r=1
    if [[ -v test_engine ]]; then
      workflow_start_group "Run tests"
      run_tests "$@" || r=1
      workflow_end_group
    fi
    exit $r
    ;;
  lint)
    for_each_package_sources lint_package
    exit $?
    ;;
  compile)
    for_each_package_sources compile_package
    exit $?
    ;;
  test)
    run_tests "$@"
    exit $?
    ;;
  shell)
    if [[ $# -eq 0 ]]; then
      shell_with_packages
    else
      shell_with_packages --command "$*"
    fi
    ;;
  *)
    echo "Unsupported operation: $op" >&2
    exit 2
    ;;
esac
