#!/usr/bin/env bash

set -e

####################
# Set the defaults #
####################

# Directory for storing cache files
if [[ -v ELINTER_CACHE_ROOT ]]; then
  cache_dir="${ELINTER_CACHE_ROOT}"
else
  case "$OSTYPE" in
    linux-gnu*)
      cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/elinter"
      ;;
    darwin*)
      cache_dir="$HOME/Library/Caches/elinter"
      ;;
    *)
      echo "Unsupported ostype: $OSTYPE" >&2
      exit 1
      ;;
  esac
fi

config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/elinter"

user_nix_sources="${config_dir}/nix/sources.nix"

package_source_root="${cache_dir}/pkg-src"
# package_output_root="${cache_dir}/pkg-out"

# Directory containing recipes
recipes_dir=${ELINTER_RECIPES_DIR:-.recipes}

###################################
# Read the command line arguments #
###################################

# Initialize variables
op=default_check
recipes=()
packages=()
nix_packages=()
unset cleanup
unset remote
unset test_engine
# Cask setting is empty by default, but it is still interpreted as 1
unset cask
unset cask_file
unset niv_update
if [[ -v ELINTER_LINTERS ]]; then
  mapfile -d' ' -t linters <<<"${ELINTER_LINTERS}"
  # shellcheck disable=SC2206
  linters=(${linters[*]})
else
  linters=(package-lint checkdoc check-declare)
fi

usage() {
  # Follow the style in docopt https://docopt.org/
  cat <<HELP
Usage: elinter [options] <recipe>...

Options:
  -l             Do only linting (skip byte-compile)
  -b             Do only byte-compile (skip linting)
  -t|--test      Run only tests
  -c             Clean up cache before operation
  -s             Enter a shell with the packages
  --experimental Turn on experimental checks (using melpazoid)
  -B|--buttercup Run buttercup tests
  -E|--ert-runner Run ert-runner tests
  --ert          Run ert tests defined in files
  -e|--emacs VERSION
                 Set the Emacs version
  -r             Fetch the source code from a remote server
  --cask         Detect Cask file and use packages defined in it (default)
  --no-cask      Don't use cask file
  --from-nixpkgs Nix packages added to buildInputs for tests (comma-separated)
  -u|--update    Update Nix dependencies (e.g. emacs-overlay)
  -V, --version  Show version
HELP
}

version() {
  echo "elinter version ${ELINTER_VERSION:?Unknown version}"
}

# TODO: Use enhanced getopt to parse command line arguments
# See https://gist.github.com/hoylen/6607180 for example

# Loop arguments until it becomes empty
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit
      ;;
    -V|--version)
      version
      exit
      ;;
    -r)
      remote=1
      ;;
    -c|--clean)
      cleanup=1
      ;;
    -e|--emacs)
      EMACS_VERSION="$2"
      shift
      ;;
    -b|--compile)
      op=compile
      ;;
    -l|--lint)
      op=lint
      ;;
    -t|--test)
      op="test"
      ;;
    -s|--shell)
      op=shell
      ;;
    -B|--buttercup)
      test_engine=buttercup
      ;;
    -E|--ert-runner)
      test_engine=ert-runner
      ;;
    --ert)
      test_engine=ert
      ;;
    --experimental)
      linters+=(melpazoid)
      ;;
    --cask)
      use_cask=1
      ;;
    --no-cask)
      use_cask=0
      ;;
    --from-nixpkgs)
      # shellcheck disable=SC2086,SC2206
      nix_packages=(${2/,/ })
      shift
      ;;
    -u|--update)
      niv_update=(emacs-overlay nix-emacs-ci melpazoid)
      ;;
    --)
      # Keep the rest of the arguments as positional arguments
      shift
      break
      ;;
    *)
      if [[ -f "$1" ]]; then
        recipes+=("$1")
      elif [[ -d "${package_source_root}/$1" ]]; then
        packages+=("$1")
      else
        echo "Unsupported arg or missing file: $1" >&2
        exit 1
      fi
      ;;
  esac
  shift
done

#############
# Functions #
#############

emacs_versions() {
  case "${EMACS_VERSION}" in
    min|latest|all)
      nix-instantiate --eval --strict \
        --arg elispFile "./${PACKAGE_MAIN_FILE}" \
        --argstr spec "${EMACS_VERSION}" \
        --arg sources "${user_nix_sources}" \
        "share/nix/dynamicVersions.nix" \
        | tr '"[]' '   '
      ;;
    '')
      echo .
      ;;
    *)
      echo "${EMACS_VERSION}"
      ;;
  esac
}

set_emacs() {
  case "${emacs_version}" in
    ''|.)
      emacs=emacs
      return
      ;;
    snapshot)
      emacs="emacs-snapshot"
      ;;
    *)
      if [[ "${emacs_version}" =~ ^([[:digit:]]+)\.([[:digit:]])$ ]]; then
        # Skip linting if the Emacs major version is 24.3 or before
        local major=${BASH_REMATCH[1]}
        local minor=${BASH_REMATCH[2]}
        if [[ $major -lt 24 || ( $major -eq 24 && $minor -le 3 ) ]]; then
          echo "WARN: Sorry, elinter supports only Emacs 24.4 and later. Skipping" >&2
          return 1
        fi
        emacs="emacs-${emacs_version/./-}"
      else
        echo "Unsupported Emacs version: ${emacs_version}" >&2
        exit 1
      fi
      ;;
  esac
  ansi --yellow "Using $emacs"
  # Reset the installation state when the Emacs version changes
  packages_installed=0
}

update_niv_sources() {
  local targets=("$@")

  # If sources.nix does not exist in the user directory,
  # first copy the bundled version.
  if ! [[ -f "${user_nix_sources}" ]]; then
    echo "Installing sources to ${config_dir}..."
    mkdir -p "${config_dir}/nix"
    cp -n -t "${config_dir}/nix" \
       "share/nix/sources.json" "share/nix/sources.nix"
    chmod ug+w "${config_dir}/nix/sources.nix" "${config_dir}/nix/sources.json"
  fi

  if ! command -v niv >/dev/null; then
    echo "Niv is not installed in PATH." >&2
    exit 1
  fi

  echo "Updating Nix dependencies: ${targets[*]}..."

  local initial_dir="$PWD"
  cd "${config_dir}"
  for dep in "${targets[@]}"; do
    niv update "$dep"
  done
  cd "${initial_dir}"
}

discover_recipes() {
  echo "Looking for recipes in ${recipes_dir}..."
  shopt -s nullglob
  mapfile -t recipes <<<"${recipes_dir}/*"
  # Fill the gap
  # If the file name contain spaces, it may fail
  # shellcheck disable=SC2206
  recipes=(${recipes[*]})

  if [[ ${#recipes[*]} -eq 0 ]]; then
    echo "No recipe file was found." >&2
    echo "You have to specify at least one recipe file or put it in ${recipes_dir}." >&2
    exit 1
  else
    echo "Found ${recipes[*]}"
  fi
}

cleanup_cache() {
  echo "Cleaning up the cache directory..."
  rm -rf "${package_source_root}"
}

copy_package_sources() {
  echo "Linking package source files..."
  mkdir -p "${package_source_root}"
  initialdir="$(pwd)"
  for f in ${recipes[*]}; do
    package=$(basename "$f")
    if [[ "$f" = /* ]]; then
      recipe="$(cat "$f")"
    else
      recipe="$(cat "$initialdir/$f")"
    fi
    packages+=("$package")
    src="$initialdir"
    cd "${package_source_root}"
    if [[ -v remote && $remote = 1 ]]; then
      # Clean up the source every time
      rm -rf "$package"
      src=$(nix-instantiate --eval --strict \
              "share/nix/fetchSource.nix" \
              --argstr recipe "$recipe" | tr -d \")
    elif [[ -d "$package" ]]; then
      # TODO: Check for updates in the working tree
      echo
      echo "Reusing the previous settings for $package:"
      ls "$package"
      continue
    fi
    instruction=$(nix-build "share/nix/copySource.nix" \
            --no-out-link --quiet --no-build-output \
            --argstr recipe "$recipe" --argstr src "$src")
    mkdir "$package"
    cd "${package_source_root}/$package"
    # shellcheck disable=SC1090
    . "$instruction"
    echo
    echo "Package: $package"
    # shellcheck disable=SC2001
    echo "${recipe}" | sed 's/^/> /'
    echo -n "Files: "
    ls
  done
  cd "$initialdir"
}

for_each_package_sources() {
  set +e
  local r=0
  local failed_packages=()
  if [[ ${#packages[*]} -gt 1 ]]; then
    multi_packages=1
  else
    multi_packages=0
  fi
  for package in ${packages[*]}; do
    # Fork a subshell to isolate the environment, e.g. variables
    if ! (
      r=0
      cd "${package_source_root}/$package"
      # shellcheck disable=SC1091
      source .elinter-env

      if [[ -n "${ELINTER_BEFORE_PACKAGE_HOOK}" ]]; then
        ${ELINTER_BEFORE_PACKAGE_HOOK}
      fi

      ansi --blue --bold "On package ${PACKAGE_NAME}:"
      for emacs_version in $(emacs_versions); do
        if ! set_emacs; then
          break
        fi
        # shellcheck disable=SC2048
        if ! $*; then
          r=1
          # Skip the following versions if any error occurs
          break
        fi
      done

      if [[ $r -eq 0 ]]; then
        if [[ -n "${ELINTER_PACKAGE_SUCCESS_HOOK}" ]]; then
          ${ELINTER_PACKAGE_SUCCESS_HOOK}
        fi
      else
        ansi --red "Package $package failed on some checks."
        if [[ -n "${ELINTER_PACKAGE_FAILURE_HOOK}" ]]; then
          ${ELINTER_PACKAGE_FAILURE_HOOK}
        fi
      fi

      if [[ -n "${ELINTER_AFTER_PACKAGE_HOOK}" ]]; then
        # shellcheck disable=SC2090
        ${ELINTER_AFTER_PACKAGE_HOOK}
      fi

      exit $r
      ); then
      r=1
      failed_packages+=("$package")
    fi
    # Insert an empty line between packages
    gh_workflow_p && echo
  done
  if [[ $r -eq 0 ]]; then
    ansi --green "All checks were successful."
  else
    ansi --red "Some checks failed."
    if [[ ${multi_packages} -gt 0 ]]; then
      echo "Failed packages: ${failed_packages[*]}"
    fi
  fi
  return $r
}

emacs_dev_shell() {
  "${nix_shell_bin}" "share/nix/emacs.nix" -A shellForCI \
          --arg sources "${user_nix_sources}" \
          --argstr emacs "$emacs" \
          --argstr mainFile "$(pwd)/${PACKAGE_MAIN_FILE}" \
          --argstr enabledLinters "${linters[*]}" \
          "$@"
}

install_package_deps() {
  if ! [[ -v packages_installed && "${packages_installed}" = 1 ]]; then
    workflow_start_group "Install dependencies for the package"
    emacs_dev_shell --run exit
    workflow_end_group
    packages_installed=1
  fi
}

lint_package() {
  install_package_deps
  workflow_with_group "Lint" emacs_dev_shell --run elinter-run-linters
}

compile_package() {
  install_package_deps
  emacs_dev_shell --run elinter-byte-compile
}

lint_and_compile_package() {
  local r=0
  lint_package || r=1
  compile_package || r=1
  return $r
}

shell_with_packages() {
  local loadpath=()
  local mainfiles=()
  initialdir="$PWD"
  for package in ${packages[*]}; do
    unset PACKAGE_NAME
    unset PACKAGE_FILES
    unset PACKAGE_ELISP_FILES
    unset PACKAGE_MAIN_FILE
    cd "${package_source_root}/$package"
    # shellcheck disable=SC1091
    source .elinter-env
    loadpath+=("$PWD")
    mainfiles+=("$(readlink -e "${PACKAGE_MAIN_FILE}")")
  done
  cd "$initialdir"
  local r=0
  for emacs_version in $(emacs_versions); do
    if ! set_emacs; then
      break
    fi
    # shellcheck disable=SC2048
    if ! "${nix_shell_bin}" "share/nix/emacsTest.nix" \
          --argstr emacs "$emacs" \
          --argstr loadPath "${loadpath[*]@Q}" \
          --argstr mainFiles "${mainfiles[*]@Q}" \
          "$@"; then
      r=1
      # Skip the following versions if any error occurs
      break
    fi
  done
  return $r
}

run_tests() {
  ansi --blue --bold "Tests"
  local nix_args=()
  if [[ -n "${cask_file}" ]]; then
    nix_args+=("--argstr" "caskFile" "${cask_file}")
  fi
  if [[ -v nix_packages && ${#nix_packages[*]} -gt 0 ]]; then
    nix_args+=("--argstr" "extraBuildInputsFromNixPkgs" "${nix_packages[*]}")
  fi
  case "${test_engine}" in
    buttercup)
      # shellcheck disable=SC2086
      shell_with_packages \
        ${nix_args[*]} \
        --arg extraPackReqs '["buttercup"]' \
        --arg extraBuildInputs "import share/nix/buttercup.nix" \
        --run "buttercup $*"
      ;;
    ert-runner)
      # shellcheck disable=SC2086
      shell_with_packages \
        ${nix_args[*]} \
        --arg extraPackReqs '["ert-runner"]' \
        --run "emacs -Q --batch -l ert-runner"
      ;;
    ert)
      # Extra arguments passed to elinter command are loaded in the
      # Emacs session.
      local emacs_args=()
      for arg; do
        emacs_args+=("-l" "$arg")
      done
      # ert is a built-in package, so extraPackReqs is unnecessary
      # shellcheck disable=SC2086
      shell_with_packages \
        ${nix_args[*]} \
        --run "emacs -Q --batch -l ert ${emacs_args[*]} -f ert-run-tests-batch-and-exit"
      ;;
  esac
}

setup_github_workflow_annotations() {
  mkdir -p "${cache_dir}"
  # Lint and byte-compile errors are saved to this file
  export ELINTER_LOG_FILE="${cache_dir}/elinter.log"

  ELINTER_BEFORE_PACKAGE_HOOK="touch ${ELINTER_LOG_FILE}"
  ELINTER_AFTER_PACKAGE_HOOK="rm -f ${ELINTER_LOG_FILE}"
  # Produce errors on a package
  ELINTER_PACKAGE_FAILURE_HOOK="elinter-github-logger"
}

####################
# Main entry point #
####################

# Load functions related GitHub Actions from share/workflow.bash in
# this repository.
# The path should be replaced with an absolute path using
# substituteInPlace function of Nix.
# 
# shellcheck disable=SC1091
. 'share/workflow.bash'

workflow_start_group "Initialization"

if [[ -v GITHUB_ACTIONS ]]; then
  # Force setting TERM to enable color output
  export TERM=ansi
fi

# Source "ansi" script to load "ansi" function.
# 'ansi/ansi' should be replaced with an absolute path using
# substituteInPlace function of Nix.
# 
# shellcheck disable=SC1091
. 'ansi/ansi'

if nix_shell_bin="$(command -v cached-nix-shell)"; then
  echo "Using cached-nix-shell"
  echo
else
  nix_shell_bin=nix-shell
fi

if [[ -v cleanup && $cleanup = 1 ]]; then
  cleanup_cache
  echo
fi

if [[ -v niv_update ]]; then
  update_niv_sources "${niv_update[@]}"
fi
if [[ -f "${user_nix_sources}" ]]; then
  echo "Using Nix sources maintained by the user"
fi

# For most operations, at least one recipe is mandatory
if [[ ${#recipes} -eq 0 && ${#packages} -eq 0 ]]; then
  discover_recipes
  echo
fi

if [[ ${#recipes} -gt 0 ]]; then
  copy_package_sources
fi

export ELINTER_LINTERS="${linters[*]}"

if ! [[ -v use_cask && "${use_cask}" = 0 ]]; then
  if [[ -f Cask ]]; then
    cask_file="$(readlink -f Cask)"
  elif [[ "${use_cask}" = 1 ]]; then
    echo "WARNING: Cask option is set, but no Cask file is found."
  fi
fi

# Enable features that are specific to GitHub Actions
if [[ "${GITHUB_ACTIONS}" = true ]]; then
  setup_github_workflow_annotations
fi

workflow_end_group

case "$op" in
  default_check)
    r=0
    for_each_package_sources lint_and_compile_package || r=1
    if [[ -v test_engine ]]; then
      workflow_start_group "Run tests"
      run_tests "$@" || r=1
      workflow_end_group
    fi
    exit $r
    ;;
  lint)
    for_each_package_sources lint_package
    exit $?
    ;;
  compile)
    for_each_package_sources compile_package
    exit $?
    ;;
  test)
    run_tests "$@"
    exit $?
    ;;
  shell)
    if [[ $# -eq 0 ]]; then
      shell_with_packages
    else
      shell_with_packages --command "$*"
    fi
    ;;
  *)
    echo "Unsupported operation: $op" >&2
    exit 2
    ;;
esac
