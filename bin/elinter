#!/usr/bin/env bash

set -e

####################
# Set the defaults #
####################

os_cache_root() {
  # read variables from the command line
  case "$OSTYPE" in
    linux-gnu*)
      echo "${XDG_CACHE_HOME:-$HOME/.cache}"
      ;;
    darwin*)
      echo "$HOME/Library/Caches"
      ;;
  esac
}

nix_lib_dir="${ELINTER_NIX_LIB_DIR:?Cannot be empty}"

# Directory for storing cache files
cache_dir="${ELINTER_CACHE_ROOT:-$(os_cache_root)/elinter}"

# config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/elinter"

# Directory containing niv nix directory
# niv_root="${ELINTER_NIV_ROOT:-${config_dir}}"

package_source_root="${cache_dir}/pkg-src"
# package_output_root="${cache_dir}/pkg-out"

# Directory containing recipes
recipes_dir=${ELINTER_RECIPES_DIR:-.recipes}

###################################
# Read the command line arguments #
###################################

# Initialize variables
op=lint_and_compile
recipes=()
packages=()
unset cleanup
unset remote
if [[ -v ELINTER_LINTERS ]]; then
  mapfile -d' ' -t linters <<<"${ELINTER_LINTERS}"
  # shellcheck disable=SC2206
  linters=(${linters[*]})
else
  linters=(package-lint checkdoc check-declare)
fi

usage() {
  # Follow the style in docopt https://docopt.org/
  cat <<HELP
Usage: elinter [options] <recipe>...

Options:
  -l             Do only linting (skip byte-compile)
  -b             Do only byte-compile (skip linting)
  -c             Clean up cache before operation
  --melpazoid    Turn on melpazoid checks in the linting phase
  -e|--emacs VERSION
                 Set the Emacs version
  -r             Fetch the source code from a remote server
  -V, --version  Show version
HELP
}

version() {
  echo "elinter version ${ELINTER_VERSION:?Unknown version}"
}

# TODO: Use enhanced getopt to parse command line arguments
# See https://gist.github.com/hoylen/6607180 for example

# Loop arguments until it becomes empty
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit
      ;;
    -V|--version)
      version
      exit
      ;;
    -r)
      remote=1
      ;;
    -c|--clean)
      cleanup=1
      ;;
    -e|--emacs)
      EMACS_VERSION="$2"
      shift
      ;;
    -b|--compile)
      op=compile
      ;;
    -l|--lint)
      op=lint
      ;;
    --melpazoid)
      linters+=(melpazoid)
      ;;
    *)
      if [[ -f "$1" ]]; then
        recipes+=("$1")
      elif [[ -d "${package_source_root}/$1" ]]; then
        packages+=("$1")
      else
        echo "Unsupported arg or missing file: $1" >&2
        exit 1
      fi
      ;;
  esac
  shift
done

#############
# Functions #
#############

emacs_versions() {
  case "${EMACS_VERSION}" in
    min|latest|all)
      nix-instantiate --eval --strict \
        --arg elispFile "./${PACKAGE_MAIN_FILE}" \
        --argstr spec "${EMACS_VERSION}" \
        "${nix_lib_dir}/dynamicVersions.nix" \
        | tr '"[]' '   '
      ;;
    '')
      echo .
      ;;
    *)
      echo "${EMACS_VERSION}"
      ;;
  esac
}

set_emacs() {
  case "${emacs_version}" in
    ''|.)
      emacs=emacs
      return
      ;;
    snapshot)
      emacs="emacs-snapshot"
      ;;
    *)
      if [[ "${emacs_version}" =~ ^[[:digit:]]+\.[[:digit:]]$ ]]; then
        emacs="emacs-${emacs_version/./-}"
      else
        echo "Unsupported Emacs version: ${emacs_version}" >&2
        exit 1
      fi
      ;;
  esac
  echo
  echo "Using $emacs"
}

discover_recipes() {
  echo "Looking for recipes in ${recipes_dir}..."
  shopt -s nullglob
  mapfile -t recipes <<<"${recipes_dir}/*"
  # Fill the gap
  # If the file name contain spaces, it may fail
  # shellcheck disable=SC2206
  recipes=(${recipes[*]})

  if [[ ${#recipes[*]} -eq 0 ]]; then
    echo "No recipe file was found." >&2
    echo "You have to specify at least one recipe file or put it in ${recipes_dir}." >&2
    exit 1
  else
    echo "Found ${recipes[*]}"
  fi
}

cleanup_cache() {
  echo "Cleaning up the cache directory..."
  rm -rf "${package_source_root}"
}

copy_package_sources() {
  echo "Linking package source files..."
  mkdir -p "${package_source_root}"
  initialdir="$(pwd)"
  for f in ${recipes[*]}; do
    package=$(basename "$f")
    recipe="$(cat "$initialdir/$f")"
    packages+=("$package")
    src="$initialdir"
    cd "${package_source_root}"
    if [[ -v remote && $remote = 1 ]]; then
      # Clean up the source every time
      rm -rf "$package"
      src=$(nix-instantiate --eval --strict \
              "${nix_lib_dir}/fetchSource.nix" \
              --argstr recipe "$recipe" | tr -d \")
    elif [[ -d "$package" ]]; then
      # TODO: Check for updates in the working tree
      echo
      echo "Reusing the previous settings for $package:"
      ls "$package"
      continue
    fi
    instruction=$(nix-build "${nix_lib_dir}/copySource.nix" \
            --no-out-link --quiet --no-build-output \
            --argstr recipe "$recipe" --argstr src "$src")
    mkdir "$package"
    cd "${package_source_root}/$package"
    # shellcheck disable=SC1090
    . "$instruction"
    echo
    echo "Package: $package"
    # shellcheck disable=SC2001
    echo "${recipe}" | sed 's/^/> /'
    echo -n "Files: "
    ls
  done
}

for_each_package_sources() {
  set +e
  local r=0
  local failed_packages=()
  if [[ ${#package[*]} -gt 1 ]]; then
    multi_packages=1
  else
    multi_packages=0
  fi
  for package in ${packages[*]}; do
    # Fork a subshell to isolate the environment, e.g. variables
    if ! (
      cd "${package_source_root}/$package"
      # shellcheck disable=SC1091
      source .envrc

      ansi --blue --bold "On package ${PACKAGE_NAME}:"
      for emacs_version in $(emacs_versions); do
        set_emacs
        # shellcheck disable=SC2048
        if ! $*; then
          r=1
        fi
      done

      exit $r
    ); then
      r=1
      failed_packages+=("$package")
    fi
  done
  if [[ $r -eq 0 ]]; then
    ansi --green "All checks were successful."
  else
    ansi --red "Some checks failed."
    if [[ ${multi_packages} -gt 0 ]]; then
      echo "Failed packages: ${failed_packages[*]}"
    fi
  fi
  return $r
}

emacs_dev_shell() {
  "${nix_shell_bin}" "${nix_lib_dir}/emacs.nix" -A shellForCI \
          --argstr emacs "$emacs" \
          --argstr mainFile "$(pwd)/${PACKAGE_MAIN_FILE}" \
          --argstr enabledLinters "${linters[*]}" \
          "$@"
}

install_package_deps() {
  if ! [[ -v packages_installed ]]; then
    workflow_start_group "Install dependencies for the package"
    emacs_dev_shell --run exit
    workflow_end_group
    packages_installed=1
  fi
}

lint_package() {
  install_package_deps
  workflow_start_group "Lint"
  emacs_dev_shell --run elinter-run-linters
  workflow_end_group
}

compile_package() {
  install_package_deps
  workflow_start_group "Byte-compile and loadability checking"
  emacs_dev_shell --run elinter-byte-compile
  workflow_end_group
}

lint_and_compile_package() {
  local r=0
  lint_package || r=1
  if ! gh_workflow_p; then
    echo
  fi
  compile_package || r=1
  return $r
}

####################
# Main entry point #
####################

workflow_start_group "Initialization"

if [[ -v GITHUB_ACTIONS ]]; then
  # Force setting TERM to enable color output
  export TERM=ansi
fi

if [[ -v ELINTER_ANSI_LIBRARY && -f "${ELINTER_ANSI_LIBRARY}" ]]; then
  # shellcheck disable=SC1090
  . "${ELINTER_ANSI_LIBRARY}"
else
  ansi() {
    while [[ $# -gt 0 && "$1" = --* ]]; do
      shift
    done
    echo "$*"
  }
fi

if nix_shell_bin="$(command -v cached-nix-shell)"; then
  echo "Using cached-nix-shell"
  echo
else
  nix_shell_bin=nix-shell
fi

if [[ -v cleanup && $cleanup = 1 ]]; then
  cleanup_cache
  echo
fi

# For most operations, at least one recipe is mandatory
if [[ ${#recipes} -eq 0 && ${#packages} -eq 0 ]]; then
  discover_recipes
  echo
fi

if [[ ${#recipes} -gt 0 ]]; then
  copy_package_sources
fi

export ELINTER_LINTERS="${linters[*]}"

workflow_end_group

case "$op" in
  lint_and_compile)
    for_each_package_sources lint_and_compile_package
    exit $?
    ;;
  lint)
    for_each_package_sources lint_package
    exit $?
    ;;
  compile)
    for_each_package_sources compile_package
    exit $?
    ;;
  test)
    # TODO:
    ;;
  *)
    echo "Unsupported operation: $op" >&2
    exit 2
    ;;
esac
